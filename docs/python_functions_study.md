# 중첩 함수, 데코레이터, 그리고 람다 정리

## 1. 중첩 함수 (Nested Function)를 사용하는 이유

단순히 코드를 순차적으로 실행하는 것이 아니라, 로직을 포장하여 나중에 실행하거나 특정 범위 내로 제한하기 위해 사용합니다.

- 캡슐화 (Encapsulation): 특정 함수 내부에서만 필요한 보조 로직을 외부로부터 숨겨 이름 충돌을 방지합니다.
- 클로저 (Closure): 외부 함수의 변수를 기억하는 상태를 유지하는 함수를 만들 수 있습니다.
- 유지보수성: 함수가 너무 길어질 때, 외부로 빼기엔 재사용성이 낮은 로직을 내부에서 격리하여 관리합니다.

## 2. 데코레이터 (Decorator)

- 개념: 기존 함수의 코드를 수정하지 않고 기능을 추가하는 '겉포장지' 역할을 합니다.
- 장점: 로깅, 권한 확인, 실행 시간 측정 등 공통 기능을 한 곳에서 관리할 수 있어 유지보수가 매우 용이합니다.

## 3. 람다 (Lambda)

- 개념: 이름이 없는 일회용 익명 함수입니다.
- 장점: `map()`, `filter()`, `sorted()` 등과 함께 사용하여 아주 짧고 간결한 로직을 즉석에서 처리할 때 유용합니다.

## 4. 요약

- 조건문/반복문: 데이터의 즉각적인 일괄 처리.
- 중첩 함수: 로직의 격리, 상태 보존, 기능의 확장.
- 언어 지원: Python 외에도 JavaScript, Swift, Kotlin, Rust, Java 등 현대적인 언어 대부분이 지원합니다.
